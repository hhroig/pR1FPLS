#' Crossvalidated Functional Principal Components Regression using 2D Finite Elements basis
#'
#' @param X a number-of-observations times nodes matrix.
#' @param Y a number-of-observations times reponses matrix.
#' @param ncomp number of components, integer.
#' @param center center the data.
#' @param basisobj a Finite Elements basis as in the fdaPDE package.
#' @param penalty_vec a vector of possible penalties.
#' @param PCAvalidation validation method in \code{fdaPDE::FPCA.FEM}.
#' @param NFolds number of folds to use in \code{fdaPDE::FPCA.FEM}.
#' @param folds a user defined list of folds (as generated by caret::createFolds())
#' or an integer indicating the number of folds. Independent of
#' \code{fdaPDE::FPCA.FEM}'s validation.
#' @param verbose logical, indicating if messages should be printed.
#' @param stripped logical.  If \code{TRUE} the calculations are stripped as
#' much as possible for speed. Particularly, if \code{FALSE} (default) it computes
#' the final models using the best combination of penalties.
#' Inspired by package \code{pls}.
#' @param ... further arguments.  Currently not used
#'
#' @return A list of crossvalidates erros (CVEs) and penalties giving the minimum
#' CVEs per number of components.
#' @export
#'
#' @examples
#' # 2D example:
#'
#' # Generate data (30 samples, 100 nodes):
#' x <- seq(0, 1, length.out = 10)
#' y <- seq(0, 1, length.out = 10)
#'
#' L <- generate_2d_data(x, y, 30, 3, 0.95)
#'
#' X <- L[["X"]]
#' Y <- L[["Y"]]
#' FEM_basis <- L[["basisobj"]]
#'
#' cv_fpcr <- cv_fpcr(X = X, Y = Y, penalty_vec = c(0.01, 10, 100), center = TRUE,
#'                   ncomp = 3, folds = 5, PCAvalidation = "KFold", NFolds = 5,
#'                   basisobj = FEM_basis, verbose = TRUE, stripped = FALSE)
#'
#' final_fpcr <- cv_fpcr$final_model
cv_fpcr <- function(X,
                    Y,
                    ncomp = min(10, ncol(X)),
                    center = TRUE,
                    basisobj,
                    penalty_vec = c(0.0001, 0.5, 1, 10),
                    PCAvalidation = "KFold",
                    NFolds = 5,
                    folds = 5,
                    verbose = TRUE,
                    stripped = TRUE,
                    ...) {

  tictoc::tic("Crossvalidation")

  if (is.numeric(folds)) {

    num_folds <- folds
    folds <- caret::createFolds(Y, k = num_folds)

  }else if (is.list(folds)) {

    num_folds <- length(folds)

  }

  # Initialize MSEs:
  MSE_ncomp_fold <- matrix(data = NA,
                           nrow = ncomp,
                           ncol = num_folds) # MSE per component per fold
  colnames(MSE_ncomp_fold) <- paste0("fold_", 1:num_folds)
  rownames(MSE_ncomp_fold) <- paste0("ncomp_", 1:ncomp)

  for (ncomp_i in 1:ncomp) {

    if (verbose) {
      cat("Component ", ncomp_i, "/", ncomp, "\n")
    }


    for (i in 1:num_folds) {

      if(verbose){
        cat("  Fold ", i, "/", num_folds, "\n")}

      # build train
      Y_fold_train <- Y[-folds[[i]], , drop = F]
      X_fold_train <- X[-folds[[i]], , drop = F]

      # build test:
      Y_fold_test <- Y[folds[[i]], , drop = F]
      X_fold_test <- X[folds[[i]], , drop = F]


      res_fpls <- fpcr_fem(X = X_fold_train,
                           Y = Y_fold_train,
                           ncomp = ncomp_i,
                           center = center,
                           basisobj = basisobj,
                           penalty_vec = penalty_vec,
                           PCAvalidation = PCAvalidation,
                           NFolds = NFolds,
                           verbose = FALSE,
                           stripped = stripped )

      MSE_ncomp_fold[ncomp_i, i] <- mean(as.numeric(Y_fold_test -
                                                      stats::predict(object = res_fpls,
                                                                     newdata = X_fold_test))^2)


    } # end k-fold


  } # loop in ncomp: number of components

  # Save the folds-averaged CV error:
  CVEs_ncomp <- rowMeans(MSE_ncomp_fold)
  names(CVEs_ncomp) <- paste0("ncomp_", 1:ncomp)

  if (stripped) {

    ret <- list(CVEs_ncomp = CVEs_ncomp,
                MSE_ncomp_fold = MSE_ncomp_fold,
                elapsed = tictoc::toc(quiet = !verbose)   )
  }else {

    if (verbose) {
      cat("Fitting final model\n")
    }

    final_model <- fpcr_fem(X = X,
                            Y = Y,
                            ncomp = ncomp,
                            center = TRUE,
                            basisobj = basisobj,
                            penalty_vec = penalty_vec,
                            PCAvalidation = PCAvalidation,
                            NFolds = NFolds,
                            verbose = verbose,
                            stripped = stripped )

    ret <- list(CVEs_ncomp = CVEs_ncomp,
                MSE_ncomp_fold = MSE_ncomp_fold,
                best_penalties = as.numeric(final_model[["fpca_solution"]][["lambda"]]),
                final_model = final_model,
                elapsed = tictoc::toc(quiet = !verbose)    )

  }

  return(ret)

}
